% turbo_maxlogmap_demo.m
% Turbo encoder (1,5/7) rate 1/3 with Max-Log-MAP decoder

close all; clear; clc;

% --- Parameters ---
K = 100;                  % info bits
EbN0dB = 1.5;             % Eb/N0 in dB
nIter = 6;                % turbo iterations
N0 = 10^(-EbN0dB/10);     % noise variance (Eb=1)
Lc = 2/N0;                % channel reliability

% --- Trellis for (5,7) octal RSC (memory 2, constraint length 3) ---
g1 = [1 1 1];   % 7 (111)
g2 = [1 0 1];   % 5 (101)
m = 2;
nStates = 2^m;

% Precompute next-state and parity tables
nextState = zeros(nStates,2);
parityBit = zeros(nStates,2);
for state=0:nStates-1
    sr = bitget(state, m:-1:1); % shift register bits
    for u=0:1
        input = u;
        % feedback = input xor sr(end)
        fb = xor(input, sr(end));
        % new state = shift register with feedback
        new_sr = [fb sr(1:end-1)];
        ns = bi2de(new_sr, 'left-msb');
        nextState(state+1,u+1) = ns;
        % parity = sum(g1.*[fb sr]) mod 2
        p1 = mod(sum(g1 .* [fb sr]),2);
        parityBit(state+1,u+1) = p1;
    end
end

% --- Random info bits ---
u = randi([0 1], 1, K);

% --- Turbo encoder ---
% First RSC
[s1,p1] = rsc_encode(u, g1, g2, m);
% Interleaver
pi = randperm(K);
u_int = u(pi);
[s2,p2] = rsc_encode(u_int, g1, g2, m);
% Tx sequence: sys, parity1, parity2
tx = [s1; p1; p2];

% --- BPSK modulation ---
txSym = 1 - 2*tx;
rx = txSym + sqrt(N0/2)*randn(size(txSym));

% Channel LLRs
L_sys = Lc * rx(1,:);   % systematic
L_p1  = Lc * rx(2,:);   % parity1
L_p2  = Lc * rx(3,:);   % parity2

% --- Turbo decoder ---
La = zeros(1,K);   % initial a-priori
for iter=1:nIter
    % Decoder 1 (systematic + parity1)
    Lext1 = maxlogmap_decoder(L_sys, L_p1, La, nextState, parityBit);
    % Interleave extrinsic
    La2 = Lext1(pi);
    % Decoder 2 (interleaved systematic + parity2)
    L_sys_int = L_sys(pi);
    Lext2 = maxlogmap_decoder(L_sys_int, L_p2(pi), La2, nextState, parityBit);
    % Deinterleave extrinsic
    La = zeros(1,K);
    La(pi) = Lext2;
end

% Final decision
L_total = L_sys + La;
u_hat = (L_total < 0);

nErr = sum(u ~= u_hat);
fprintf('Errors: %d / %d\n', nErr, K);

% --- Helper functions ---

function [sys,parity] = rsc_encode(u,g1,g2,m)
    N = length(u);
    sys = u;
    sr = zeros(1,m);
    parity = zeros(1,N);
    for k=1:N
        fb = xor(u(k), sr(end));
        p = mod(sum(g1.*[fb sr]),2);
        parity(k) = p;
        sr = [fb sr(1:end-1)];
    end
end

function Lext = maxlogmap_decoder(L_sys,L_par,La,nextState,parityBit)
    K = length(L_sys);
    nStates = size(nextState,1);
    % init metrics
    alpha = -inf(nStates,K+1); alpha(1,1)=0;
    beta  = -inf(nStates,K+1); beta(:,K+1)=0;
    gamma = -inf(nStates,2,K);
    % branch metrics
    for k=1:K
        for s=1:nStates
            for u=0:1
                ns = nextState(s,u+1)+1;
                p = parityBit(s,u+1);
                g = 0.5*((1-2*u)*La(k) + (1-2*u)*L_sys(k) + (1-2*p)*L_par(k));
                gamma(s,u+1,k) = g;
            end
        end
    end
    % forward
    for k=1:K
        for s=1:nStates
            for u=0:1
                ns = nextState(s,u+1)+1;
                alpha(ns,k+1) = max(alpha(ns,k+1), alpha(s,k)+gamma(s,u+1,k));
            end
        end
    end
    % backward
    for k=K:-1:1
        for s=1:nStates
            for u=0:1
                ns = nextState(s,u+1)+1;
                beta(s,k) = max(beta(s,k), beta(ns,k+1)+gamma(s,u+1,k));
            end
        end
    end
    % extrinsic LLR
    Lext = zeros(1,K);
    for k=1:K
        num=-inf; den=-inf;
        for s=1:nStates
            for u=0:1
                ns = nextState(s,u+1)+1;
                val = alpha(s,k)+gamma(s,u+1,k)+beta(ns,k+1);
                if u==0, num=max(num,val);
                else, den=max(den,val);
                end
            end
        end
        Lapp = num - den;
        % extrinsic = Lapp - channel(sys) - a-priori
        Lext(k) = Lapp - L_sys(k) - La(k);
    end
end
